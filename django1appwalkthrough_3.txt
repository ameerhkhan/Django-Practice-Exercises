Django App Development..

Begins from where last Walkthrough (django1appwalkthrough_2.txt --> Testing) left off..

Let's begin again.

=========================================
STATIC FILES MANAGEMENT
=========================================

We’ve built a tested Web-poll application, and we’ll now add a stylesheet and an image.

Aside from the HTML generated by the server, web applications 
generally need to serve additional files — such as images, JavaScript, or CSS — necessary to render 
the complete web page. 
In Django, we refer to these files as “static files”.


For small projects, this isn’t a big deal, 
because you can keep the static files somewhere your web server can find it. 
However, in bigger projects – especially those comprised of multiple apps – dealing with 
the multiple sets of static files provided by each application starts to get tricky.

That’s what django.contrib.staticfiles is for: it collects static files from each of your 
applications (and any other places you specify) into a single location that can easily be served in production.

Customize your app’s look and feel
==================================
First, create a directory called static in your polls directory. Django will look for static files there, 
similarly to how Django finds templates inside polls/templates/.

Within the static directory you have just created, create another directory called 
polls and within that create a file called style.css. 
In other words, your stylesheet should be at polls/static/polls/style.css

Put the following code in that stylesheet (polls/static/polls/style.css):

polls/static/polls/style.css"""

li a {
    color: green;
}

"""

Next, add the following at the top of polls/templates/polls/index.html:

polls/templates/polls/index.html"""

{% load static %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}">

"""

The {% static %} template tag generates the absolute URL of static files.

That’s all you need to do for development.

Start the server (or restart it if it’s already running):



Adding a background-image
=========================

Next, we’ll create a subdirectory for images. 
Create an images subdirectory in the polls/static/polls/ directory. 
Inside this directory, put an image called background.gif. 
In other words, put your image in polls/static/polls/images/background.gif.

Then, add to your stylesheet (polls/static/polls/style.css):

polls/static/polls/style.css"""

body {
    background: white url("images/background.gif") no-repeat;
}

These are the basics. For more details on settings and other bits included 
with the framework see the static files howto and the staticfiles reference. 
Deploying static files discusses how to use static files on a real server.

========================================================================================
########################################################################################
========================================================================================

We’re continuing the Web-poll application and will focus on customizing Django’s 
automatically-generated admin site that we first explored in Tutorial 2.

Customize the admin form
========================

By registering the Question model with admin.site.register(Question), 
Django was able to construct a default form representation. 
Often, you’ll want to customize how the admin form looks and works. 
You’ll do this by telling Django the options you want when you register the object.

Let’s see how this works by reordering the fields on the edit form. 
Replace the admin.site.register(Question) line with:

polls/admin.py"""

from django.contrib import admin

from .models import Question


class QuestionAdmin(admin.ModelAdmin):
    fields = ['pub_date', 'question_text']

admin.site.register(Question, QuestionAdmin)

"""

You’ll follow this pattern – create a model admin class, then pass it as the 
second argument to admin.site.register() – any time you need to change the admin options for a model.

This particular change above makes the “Publication date” come before the “Question” field:

And speaking of forms with dozens of fields, you might want to split the form up into fieldsets:

polls/admin.py"""

from django.contrib import admin

from .models import Question


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date']}),
    ]

admin.site.register(Question, QuestionAdmin)

"""

The first element of each tuple in fieldsets is the title of the fieldset. 
Here’s what our form looks like now:

        https://docs.djangoproject.com/en/3.0/_images/admin08t.png


Adding Related Objects
======================

We have our Question admin page, but a Question has multiple Choices, 
and the admin page doesn’t display choices.

Yet.

There are two ways to solve this problem. 
The first is to register Choice with the admin just as we did with Question:

polls/admin.py"""

from django.contrib import admin

from .models import Choice, Question
# ...
admin.site.register(Choice)

"""

Now “Choices” is an available option in the Django admin. The “Add choice” form looks like this:

https://docs.djangoproject.com/en/3.0/_images/admin09.png

But, really, this is an inefficient way of adding Choice objects to the system. It’d be better 
if you could add a bunch of Choices directly when you create the Question object. Let’s make that happen.

Remove the register() call for the Choice model. Then, edit the Question registration code to read:

polls/admin.py"""

from django.contrib import admin

from .models import Choice, Question


class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)

"""


This tells Django: “Choice objects are edited on the Question admin page. 
By default, provide enough fields for 3 choices.”

Load the “Add question” page to see how that looks:

It works like this: There are three slots for related Choices – as specified by extra – and each 
time you come back to 
the “Change” page for an already-created object, you get another three extra slots.

One small problem, though. It takes a lot of screen space to display all the fields 
for entering related Choice objects. For that reason, Django offers a tabular way of 
displaying inline related objects. 
To use it, change the ChoiceInline declaration to read:

polls/admin.py"""

class ChoiceInline(admin.TabularInline):
    #...

"""

Customize the admin change list
===============================

Now that the Question admin page is looking good, let’s make some tweaks 
to the “change list” page – the one that displays all the questions in the system.

By default, Django displays the str() of each object. But sometimes it’d be more helpful 
if we could display individual fields. To do that, use the list_display admin option, 
which is a tuple of field names to display, as columns, on the change list page for the object:

polls/admin.py"""

class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ('question_text', 'pub_date', 'was_published_recently')

"""

You can click on the column headers to sort by 
those values – except in the case of the was_published_recently header.

Let's change the heading for was_published_recently which is basically the same name but 
without the underscores.

polls/models.py"""

class Question(models.Model):
    # ...
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now
    was_published_recently.admin_order_field = 'pub_date'
    was_published_recently.boolean = True
    was_published_recently.short_description = 'Published recently?'

"""

Edit your polls/admin.py file again and add an improvement to the 
Question change list page: filters using the list_filter. 
Add the following line to QuestionAdmin:

polls/admin.py"""

list_filter = ['pub_date']

"""


That adds a “Filter” sidebar that lets people filter the change list by the pub_date field:

The type of filter displayed depends on the type of field you’re filtering on. 
Because pub_date is a DateTimeField, Django knows to give appropriate 
filter options: “Any date”, “Today”, “Past 7 days”, “This month”, “This year”.

Now, let's give the app a search capability,

polls/admin.py""" QuestionAdmin

search_fields = ['question_text']

"""

That adds a search box at the top of the change list. When somebody enters search terms, 
Django will search the question_text field. You can use as many fields as 
you’d like – although because it uses a LIKE query behind the scenes, limiting the number of 
search fields to a reasonable number will make it easier for your database to do the search.


Now’s also a good time to note that change lists give you free pagination. 
The default is to display 100 items per page. 
Change list pagination, search boxes, filters, date-hierarchies, 
and column-header-ordering all work together like you think they should.

Customize the admin look and feel
=================================

Clearly, having “Django administration” at the top of each admin page is ridiculous. 
It’s just placeholder text.

You can change it, though, using Django’s template system. 
The Django admin is powered by Django itself, and its interfaces use Django’s own template system.

Customizing your project’s templates
------------------------------------

Create a templates directory in your project directory (the one that contains manage.py). 
Templates can live anywhere on your filesystem that Django can access. 
(Django runs as whatever user your server runs.) 
However, keeping your templates within the project is a good convention to follow.


Open your settings file (mysite/settings.py, remember) and add a DIRS option in the TEMPLATES setting:

onedjangosite/settings.py"""

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

"""


DIRS is a list of filesystem directories to check when loading Django templates; it’s a search path.


Just like the static files, we could have all our templates together, 
in one big templates directory, and it would work perfectly well. 
However, templates that belong to a particular application should be placed in 
that application’s template directory (e.g. polls/templates) rather than the project’s (templates).

Now create a directory called admin inside templates, and copy the template admin/base_site.html from 
within the default Django admin template directory in the source code 
of Django itself (django/contrib/admin/templates) into that directory.


If you have difficulty finding where the Django source files are located on your system, 
run the following command:

    > py -c "import django; print(django.__path__)"


Then, edit the file and replace {{ site_header|default:_('Django administration') }} 
(including the curly braces) 
with your own site’s name as you see fit. 
You should end up with a section of code like:

In an actual project, you would probably use the 

django.contrib.admin.AdminSite.site_header 

attribute to more easily make this particular customization.

Note that any of Django’s default admin templates can be overridden. To override a template, 
do the same thing you did with base_site.html – copy it from the default directory 
into your custom directory, and make changes.


Customizing your application’s templates
========================================

Our poll application is not very complex and doesn’t need custom admin templates. 
But if it grew more sophisticated and required modification of Django’s standard admin 
templates for some of its functionality, it would be more sensible to modify the application’s templates, 
rather than those in the project. That way, you could include the polls application 
in any new project and be assured that it would find the custom templates it needed.

See the template loading documentation for more information about how Django finds its templates.


Customize the admin index page
==============================
On a similar note, you might want to customize the look and feel of the Django admin index page.

By default, it displays all the apps in INSTALLED_APPS that have been registered with the 
admin application, in alphabetical order. You may want to make significant changes to the layout. 
After all, 
the index is probably the most important page of the admin, and it should be easy to use.


The template to customize is admin/index.html. (Do the same as with admin/base_site.html in the 
previous section – copy it from the default directory to your custom template directory). 
Edit the file, and you’ll see it uses a template variable called app_list. 
That variable contains every installed Django app. Instead of using that, 
you can hard-code links to object-specific admin pages in whatever way you think is best.